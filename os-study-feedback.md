## 5월 22일 ~ 6월 3일 동안 작성한 수업 필기내용
- redmine 문법으로 작성되서 보기 불편쓰

### <5월 22일 - OS 교육_Exercise 리뷰 & Chapter 1>

* 커널에 현재 시간이 항상 기록될까?
 - 현대의 OS들은 시간을 관리한다. 즉, 커널에서 시간을 관리하는 것이 맞다.
 - 프로그램 간의 시간 동기화(sync)가 필요하기 때문에, 하나의 동일한 시간을 설정해 둘 필요가 있다.
 - NTP(Network Time Protocol) : 서버로부터 시간을 가져와서 주기적으로 동기화한다.
 - 이렇게 동기화된 시간은 커널에도 기록이 된다.
 - 하나의 시간 정보를 기준으로 그것을 공유하는 것이 효율적
 *** 메인 보드의 수은전지 -> 시계 배터리
   - NTP 업데이트 => 커널 업데이트 => RTC 업데이트

* 사용자가 직접 (사용자-커널)모드를 변경하는 것은(OS 존재 의미가 사라짐) 절대 허가가 되지 않는다. 
* 사용자-커널 모드는 함께 작동하며 동기화되는 것이 아니다. 

* 프로세스 vs 스레드
 - 메모리의 공유 여부에 따라 달라진다. 
 
* deadlock(교착상태)
 - https://jhnyang.tistory.com/2 참고..
 - A와 B의 실행 순서가 순차적이지 않을 때, 두 개의 프로세스에서 이용하고자 하는 자원이 중복된다면 
 - 서로 확보하고 있는 자원을 확보하기 위해 무한 대기 상태에 들어가게 된다.
 - ex) 타이머에 의한 교착상태

* 가상화 
 - CPU, Memory, Storage, I/O = 하드웨어
 - Process - Kenel - VM 의 형태로 구축
 - VM : 커널의 입장에서 하드웨어로 인식될 수 있도록 하는 것. 
 - OS의 종류에 따라 VM이 hypervisor인지 인식할 수도, 없을 수도 있다.

***

### <0525 OS 수업>

* Operating System Structure
-> 프로세스가 잘 돌아가도록 하는 환경
* user program이 돌아가는 동안 OS는 무엇을 할까?
** 프로그램이 돌아가도록 커널이 환경을 할당(커널 서비스)

* 커널 모드 != 커널 서비스

* 커널이 하는 것
1. 파일 서비스
2. 통신
3. 오류 감지
4. resource allocation
5. Accounting(예를 들면 작업관리자)
> os system call
> ps 명령어 => PID와 Process name
> 프로그램의 addr, stat 알려줌
6. protection&security

* Rbac(role-based access conrtol)
** 접근제어장치
** 그룹별 오너 
** 네트워크 관련 기능은 access 기반으로 많이 한다.
** ex) apache를 루트 권한으로 설정 시, apache 상에 사소한 문제 하나가 발생되면 큰 영향

* trap
** 사용자 address(logical address) => physical address로 변환할때(transition)
** 메모리 오 접근(권한 문제)

*VPN
** Network application
** 두 개의 피시가 같은 네트워크 인것 처럼, 같은 도메인에 있는 것 처럼!

* system call != function call
** intruction을 하나 실행하기 위하여 어떤 것들이 작동하였는가
** 시작지점 : trap

* Loop로 파일을 입출력하는 이유는 무엇일까?
> 파일을 read, write할 공간이 있는지 확인하기 위해서

*ltrace : 어떤 C 라이브러리 함수를 호출하였는가?

*stack
** function call에서 주로 쓰임
** 레지스터가 부족할 때 쓰임
** 중첩되는 function call의 데이터를 차곡차곡 쌓아 return
** 예시를 찾아볼 필요!

* 프로세스 간 메모리는 구분된다.

* 디버깅의 방법
** 로그 분석
** 사후 분석
> 프로그램을 죽이면서 디버깅
*
** 코드 덤프 : 커널이 Exception을 죽였을 때 남기는 것
> 예외처리를 할 당시의 모든 환경사항을 저장(X-ray)
> 커널이 죽으면 메모리 전체가 Dump되는 현상이 있음
*
** 주기적인 샘플링 기법

***

### <0526 OS 교육 내용 정리>

* OS의 메모리 보호 기법은 다른 메모리 보호 기법과 구분되어야 한다.

* Pseudo 코드 작성 시 유의!
** 반드시 다른 사람도 알아볼 수 있는 코드로, 알고리즘으로 구현

* 타이머 리뷰
** NTP 초기화? => 실제적으로 OS 부팅 시에는 RTC 초기화가 먼저 일어남.
** 1. RTC 초기화
   2. 타이머 설정(set up - 주기적으로 발생하여 한 번만 설정해도 되는 타이머가 아닌 이상, loop 문으로 반복 설정 필요)
   3. interrupt 간격 설정(tick의 단위 설정 - 예를 들어 1/1000초)
   4. 설정된 interrupt 발생
   5. 타이머 핸들러로 넘어감.
   6. tick의 간격만큼 시간이 이동했음을 감지
   7. 초기화된 시간에 tick의 간격을 더한다.

* 커널 Data Structure(책 pg34~)
** tree
** 검색을 효율적으로 하기 위한 수단

* 주로 array가 가장 많이 쓰인다.
** 리스트 : 고정이 안된 크기
** 배열 : 고정된 크기(메모리 공간 활용에 더 효율적일 수도 있음)

* 커널에서 가장 많이 쓰이는 자료구조는 
** 해쉬 링크드 리스트

***

### <0527 OS 교육내용 정리>

* job과 process
> 현대에는 process로 기억

* program : instruction의 집합
** process :  이러한 instruction을 실행하는 과정인 프로그램 내의 한 흐름

* 프로세스의 구성
> 텍스트 : 프로그램이 수행할 인터럭션 코드 => 메인 메모리에 로드
> 카운터 : 로드된 인터럭션의 주소를 간직(jump할 수 있도록)
> 인터럭션 내에는 자체에 인코딩된 레지스터의 번호가 존재한다.

* CPU 레지스터 != 프로세스 레지스터

* caller와 callee
** caller : function call 실행
** callee : 호출되어 함수 실행, return해야하는 반환값 
> caller의 스택에는 function call 후 return address가 쌓임
> callee의 스택은 비휘발성 레지스터가 할당됨.
> callee가 받아들이는 function argument의 데이터 크기에 따라 메모리 저장 위치가 달라진다
> return value와 Parameter가 크면 스택에, 적당하면 레지스터에.

* Global/Local variable의 차이?
** 메모리를 기준으로 값이 얼마나 지속되느냐
** 전역변수와 달리 지역변수는 지역변수가 쓰이는 함수가 종료되면 메모리 상에서 삭제
** static 변수는 예외

* 데이터 섹션
** 코드에 포함이 된 부분이다.
** Global & Static 변수
** 초기화 변수 섹션
** 초기화 안된 변수 섹션
> 초기화되지 않은 변수 데이터 메모리는 임의의 값으로 모두 채워진다.

* HIP
** 함수에서 dynamic하게 메모리가 할당되는 것.

***

### <0528 OS 교육내용 정리>

* 프로세스!
** 하나의 프로그램은 멀티 프로세스로 진행

* proc : 커널 인터페이스

* Exception을 수용하기 위한 공간 : 8bit
* instruction & data를 수용하기 위한 공간 : 64bit

*64비트 => 2의 24승 공간!
** 2의 24승 * 1/2 를 넘어서는 공간으 커널에서 사용하는 공간

* 1MB => 1TB(100만배의 차이)
> 각 단위별로 10의 3승 단위씩 차이

* 프로세스의 *상태* => *스케줄러*의 핵심
* *스케줄러* => *프로세스*의 핵심!

*프로세스의 상태 : 
* running(실행 중) :
> 프로그램의 instruction, 즉 프로세스의 코드를 실행 중인 상태
* waiting(할 일 없이 대기 - event를 기다리는 중) : 
> 프로세스가 외부의 할일을 대기하는중 => 당장 CPU가 프로세스를 맡아도 할일이 없는 상태
> ex) IO 입출력 인터럽트를 대기.
* ready(할일 있는 채로 대기) : 
> 언제든지 실행할 준비가 되어있는 상태 => ready to run => CPU가 프로세스를 맡으면 바로 실행 상태로. 
> => 인터럽트에 의해 ready 상태가 되기를 기다리며, *프로세스 스케줄링의 핵심*

* select() : 프로세스 상태를 waiting으로 두는 system call
* sleep() : sleep()을 써야하는 경우에는, 아주 명확한 warn time을 기준으로 설정 필요

* 타이머의 속도를 무조건 빨리하는 것이 좋을까?
> context switching의 오버헤드가 생각보다 크기 때문에, 지나치게 빠른 속도로 타이머를 설정하는 것은 좋지 않음.
> 타이머가 조금씩 빨라진 이유는 그냥 기술의 발전으로 인한 것..

* 스레드
** PCB 입장에서 스레드 : 프로그램 카운터
** 하나의 프로세스 안에서의 스레드 :
> 메모리 뿐만 아니라 많은 것을 공유!
> 스레드마다 다른 instruction의 주소를 실행, 보관(레지스터도 마찬가지)

*CPU 스레드 != 프로세스 스레드
** CPU 스레드는 프로세스를 스레드처럼 보는 것 일뿐.
** Hyper Threading

***

### <0529 OS 교육내용 정리>

* 프로세스
> 메모리 => 한정된 자원
> ready 상태 => running으로 스케줄이 가능한 상태
> 따라서 ready 상태를 저장하고 있는 부분이 모두 RAM에 있다면 out of memory 현상을 일으킬 것!

* 이에 대한 보완을 위한 장치 : swap
> RAM을 확장해서 쓰는 개념
> RAM보다 싸고, 용량이 크다(백업 공간)
> 그러나 지나치게 많은 용량의 swap은 속도를 느리게 하는 원인

* 일반적인 메모리?
** 어떠한 기능에 대해 한정된 메모리 이상을 사용하지 않도록 통제(appliance)
** 특수목적 수행을 위한 .. ex) 웹 방화벽
** swap도 마찬가지로 메모리 풀이 나지 않도록 통제가 필요.

* Context Switch
** CPU가 프로세스를 필요에 따라 스케줄링(실행, 대기, 정지)
** 이에 대해 보통은 효율성/정확성 을 잡고자 노력
> OS에서는 효율성도 중요하지만, *정확성*이 더 중요
> 얼마나 정확하게 context switching을 하느냐

* 프로세스의 올바른 이해을 위해서는 프로세스 *생성 및 종료* 를 이해해야 한다.
** Parent-Child process 관계 이해
** Child = 첫 생성 시 Parent 프로세스의 복사본 => 물론, 실행이 되면서 실행 코드는 변경된다.
** ex) fork() : Child 생성(복사본)
       exec() : 새로운 코드로 원래 코드를 덮게 되는 실행 부분.(즉, parent를 기준으로 다른 소스코드를 실행하게 되는 것.)

* PID(process ID)
** 프로세스 아이디는 한정적인 자원이다
** 프로세스가 정지되면 반환, 새로운 프로세스에 할당

* pipe grap-
** 입력1 = > 출력2 / 입력2 => 출력1
** 남용하지 말고, 최소화 할 수 있으면 최소화 하는 것이 낫다.

***
### <0601 os 교육내용정리>_ Thread

* position independent code (PIC)
> 메모리의 어딘가에 위치한 기계어 코드의 몸체
> 절대 주소와 관계 없이 적절히 실행된다.(위키 참조)

* 메모리 맵에서 rwxp 항목 중 p?
> p = private = copy on write
> 일종의 알고리즘적 표현으로, write할 때 copy가 된다는 말.
> 단순 copy => 하나의 프로세스를 여러 개의 포인터로 가리키는 것.
> 여기서 write이 된다면!? => 실행이 된다는 뜻! 
> => 실제로 메모리 공간이 독립되어 할당되고, 새로운 정보 입력이 필요해질 때 copy 상태에서 실행과 동시에 복사를 진행한다.
> 이때부터 복사본을 기반으로 한 새로운 코드가 만들어지는 것.
> ( lazy-evaluation - 불필요한 연산을 줄이기 위해서 연산을 늦추는 것)

* SMT(simultaneous multi-thread)
** super scalar thread => CPU를 최적화, 하나의 실행스름에서 각각 실행흐름을 만들어서 실행.

* Thread 
> => 독립적인 실행흐름을 만들기 위한 것.
> 독립적인 인터럽트 구동
* Thread란?
** 프로세스와 상반된 의미//메모리를 공유한다는 점에서
** 프로세스 입장에서 메모리 공유는 오버헤드인가?
> 앞서 언급된 '포인터', 즉 copy 형태의 메모리 공유는 실질적인 전체 copy가 아니기 때문에 딱히 오버헤드라고 볼 수 없다.
> 메모리 공유가 필요하냐 안필요하냐에 따라 OS 코드가 달라짐.

* 다중 코어 프로그래밍 
> 병렬성이 있을 때!

* Amdahl's Law
** 프로파일링 중 내 프로그램이 어디에 시간을 많이 쓰는지 확인, 체크할 필요가 있다.
** 사용 %가 높은 것을 최적화하여야 실행 속도의 향상을 이룰 수 있다.

* 멀티 쓰레드 모델
** 커널관리/프로세스 관리 스레드 => 리눅스에서는 같은 하나
** 커널 최적화 스레드 모델 : Many to one(Amdahl's Law)

* fork() 전후 데이터 업데이트 후에 대해 알아두자!
> 프로세스 : 같지 않음
> 스레드 : 같음(메모리 공유!!!)

* Signal Handling(신호 처리)
> 다양한 신호에 대한 처리
> 미리 등록한 Handler 작동
> 내 실행 흐름에서 호출되는 것이 아님.
> signal handler은 언제든지 call 될 수 있으며, 
> user program과 handler 간의 sync 현상에서 많은 이슈들이 발생하므로 
> 최대한 적게 일하도록 하는 것이 좋다...
> 대체로 호출되어도 바로 발생하지 않고, 이러한 이벤트가 발생했다.. 식의 신호만 준다.

* signal handler 예시
> apache daemon 죽일 때
> 설정 파일 reload(데몬을 죽이고 새로 로드) => 이벤트 발생 시 Global 변수를 1로 셋팅한다

***

* man 페이지의 SEE ALSO 항목 항상 눈여겨보기
* 리눅스 프로그래밍의 정석
** Advanced Programming in Unix Environment

***

### <0602 os 교육내용 정리>

* 하나의 프로세스 내에서 동기화가 필요한가?
> signal handler의 이슈 해결을 위해 필요
> 원래 실행흐름 자체에서 이슈 발생

* 멀티스레드의 메모리 공유..기억..

* static 변수에 대해 멀티스레드에서 동기화가 필요한가?
> YES. stack에 쌓이는 변수일 것이기 때문에.
> 지역변수이지만 전역변수와 같이 변하지 않는 값을 지니고 있기 때문에.

* 멀티 프로세스도 마찬가지로 동기화 신경써야함.

* counter++ => 1. write 2. calculate 3. write

* atomic : 동시에 여러개의 동작을 진행할 수 없다.

* 커널 스페이스 : 하나 / 코어 : 여러개

* SMP(simultaneous multi process) 

* lock의 시작과 끝?
> 시작 :load 끝 : store

***

### <0603 os 교육내용 정리>

* critical section의 진입
> lock의 활용

* lock 매커니즘?
> 프로세스 => 동시 실행개념 아님!
> 만약 유저 프로세스 간 끊임없는 스케줄링이 되어있다면? => lock은 필수
> 다만 유저 프로세스가 인터럽트를 disable 시킬 수 있는 사안은 없다...
> CPU 실행을 보장하는 프로그램을 아예 짤 수있다면 아마도 가능할 수도 있다.
> low-level 기기(ex 아두이노) 는 가능하다.

* interrupt를 disable한다는 의미?
> 특정 프로세스의 실행을 방해하지 않는다는 말

* 인터럽트 발생 => lock() => 프로그램 실행(atomic) => lock 해제, 인터럽트 활성화 => 인터럽트 재개
> 멀티 프로세스에서는 불가능, *싱글 프로세스* 에서만 가능.

* atomic?
> 한 실행 흐름에 중간 단계가 없다.
> 실행 흐름에 처음과 끝만 있다.
> 즉, 인터럽트가 끼어들 여지가 전혀 없다.

* test&set()
* compare&swap()
> 책의 필기내용 참고
