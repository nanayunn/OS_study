- 1) OS란 무엇인지 설명하세요.

  - OS 란 Operating System의 약자로, OS 교육에서는 커널이라고 일컬어졌다. OS는 하드웨어와 가장 밀접하게 연관되었으며, 적절한 자원 분배를 통해 하드웨어를 제어 및 관리하여 편리하고 효율적으로 프로그램을 실행할 수 있는 환경을 제공하는 것을 목적으로 하는 프로그램이다.

  

- 2) system call 동작 방식을 설명하세요.

  - system call은 주로 응용 프로그램에서 커널에게 시스템 자원을 수행해달라고 요청하는 것이다. system call이 발생하면 사용자 모드에서 커널 모드로 모드가 변경되게 된다. 커널은 system call을 구분한 뒤 해당 system call에 맞는 서비스 루틴을 호출한다. 서비스 루틴이 모두 처리되고 나면 커널 모드에서 다시 사용자 모드로 모드가 변경된다. 

  

- 3) 주로 함수 호출의 context에서, process의 stack을 설명하세요.

  - 함수 호출의 context에서 STACK은 함수 내 지역 변수, 혹은 인자의 메모리 주소가 위치하는 공간과 함수의 반환값 주소를 저장하는 공간이다. 즉, 함수 안의 어떤 변수가 선언된 뒤 함수를 실행하게 되면 함수 변수를 저장할 공간이 생겼다가 함수가 끝나고 나면 없어지게 된다. 

  

- 4) process의 상태 중 ready, running, waiting 세 가지 상태에 대해서 설명하고, 해당 상태 변경의 조건과 상태 변경의 결과 혹은 영향을 설명하세요.

  - 프로세스의 상태는 프로세스 스케줄링에 영향을 받아 변경된다. 
  - ready는 준비 단계로, 프로세스가 프로세서를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태를 의미한다. 주로 I/O 입력을 받는 것을 대기 중인 프로세스들이 이 상태에 놓여있다.
  - running은 실행 단계로, 프로세스가 프로세서를 차지하여 명령어들이 실행되고 있는 상태를 의미한다.
  - waiting은 대기 상태로, 프로세스가 입출력 완료, 시그널 수신 등 어떤 이벤트가 일어나기를 기다리고 있는 상태를 의미한다. 
  - running 상태에서 ready 상태로 전환되는 경우는 예를 들면, 인터럽트의 발생으로 인해 모드가 변경될 때 전환된다.
  - running에서 waiting 상태로 변경되는 경우는, 프로세스가 명령어 실행을 모두 완료한 후 , 입출력 요청 등의 입력 완료 이벤트를 기다리는 경우에 일어난다.
  - waiting에서 ready로 변경되는 경우에는, 입출력이 종료되어 해당 입출력을 처리해야하는 상태에 놓이게 될 때 준비 단계로 변경되게 된다.

  

- 5) process context switching은 무엇이고, 이 때 발생하는 context switching overhead에 대해서 설명하세요.

  - 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업을 Context Switching이라고 한다. 이와 같은 경우, context switching이 진행되기 전 현재의 값을 모두 저장하고 다시 로드하는 과정에서 오버헤드가 발생하게 된다. 이러한 저장과 교체 작업 도중에 CPU는 아무런 일도 하지 못하게 되어 CPU 효율도 떨어지게 된다. 

    

- 6) process fork 시의 COW ( copy on write ) 동작에 대해서 설명하고, COW와 유사한 알고리즘을 OS 외 일반적인 IT 시스템 혹은 실생활에서의 응용예를 기술하세요.

  - process를 fork 하고 별다른 변경 조건 없이 실행을 한다면 아직 메모리 복사가 일어나지 않은 채로, 프로세스가 fork한 프로세스를 '포인터'하고 있다고 볼 수 있다. 이와 달리 fork한 내용을 바탕으로 새로운 코드를 실행하게 된다면, 그때가 되어서야 메모리 복사가 이루어지며, 복사한 메모리를 바탕으로 새로운 코드가 작성이 되게 된다. 이를 COW라고 한다. 관련된 예시로는 파일을 복사할 당시 사본 파일과 원본 파일을 메모리 주소만 같게 하여 보관하다가, 한쪽이 수정되는 경우 그때가 되어서야 복제하는 것이 있다.

- 7) 하나의 user process 에 의해서 deadlock 이 발생할 수 있는 경우를 설명하세요.

  - 사용자가 짠 프로그램에 데드락 발생 요소가 있다면 발생할 수 있다. 예를 들면, 사용자가 자원을 할당하여 자원을 획득하면 lock을 거는 프로그램을 짠 뒤, 순차적으로 자원을 획득 후 free하는 것이 아니라 엇갈린 순서로 자원을 획득하도록 하여, lock이 걸린 자원을 획득하도록 한다면 해당 자원을 얻기 위해 무한 대기 상태에 빠지게 되며 deadlock이 발생하게 된다. 

- 8) 메모리의 page 단위는 linux 에서는 기본적으로 4kb 단위를 사용하고 있는데, 이런 페이지 size를 사용하는 이유를 설명하세요. 이 보다 페이지 size가 크면 좋은 경우와 반대로 페이지 size가 작으면 좋은 경우를 설명하세요.

  - 페이지 단위가 4kb인 이유는  페이지 테이블에서 물리 주소의 비트수가 12비트인데 이로 표현할수 있는 바이트 수가 4KB이기 때문이다. 
  - 페이지 사이즈가 크면 클수록 한 번에 이동해서 많은 데이터를 읽어올 수 있다는 장점이 있다. 또한 많은 데이터를 가져올 수 있기 때문에 페이지 재사용 가능성도 높아지게 된다.
  - 반면 페이지가 작으면 페이지가 클 때 불필요하게 함께 적재되는 영역이 적어지게 된다. 즉, 필요한 데이터만 메모리에 적재되어, 데이터 정밀도가 증가한다.

  

- 9) 사용자 프로그램의 compiler, linker, loader의 역활을 memory management 관점에서 설명하세요.

  - 

- 10) DMA에 대해서 간단히 설명하고, DMA와 관련된 device driver / OS 의 interrupt handler/ DMA controller / IO device controller/ Memory 각각의 상호 작용에 대해서 설명하세요.

  - DMA란, Direct Memory Access로, 직접 메모리 접근을 의미한다. 즉, 특정 하드웨어 하위 시스템이 CPU와 독립적으로 메인 시스템 메모리에 접근할 수 있도록 해주는 컴퓨터 시스템의 기능이다. 

